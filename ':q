import rclpy
import numpy as np
from rclpy.node import Node
from sensor_msgs.msg import Imu
from std_msgs.msg import Float64
from geometry_msgs.msg import PoseArray
from drone_msgs.msg import MotorCommand, SensorMessage, DistanceSensorArray, Debug
class PIDController(Node):
    def __init__(self):
        super().__init__('pid_controller_node')

        # Publishers:
        self.control_publisher = self.create_publisher(
            MotorCommand,
            '/cmd',
            1
        ) 

        self.sensor_subscriber = self.create_subscription(
            SensorMessage,
            '/imu',
            self.sensor_callback,
            1
        )

        self.planning_subscriber = self.create_subscription(
            PoseArray,
            '/path',
            self.path_callback,
            1
        )
    

        self.debug_publisher = self.create_publisher(
                Debug,
                '/csv',
                1
        )
        self.initialized = False
        self.init_roll = 0.0
        self.init_pitch = 0.0
        self.init_yaw = 0.0
        self.init_x = 0.0
        self.init_y = 0.0
        self.init_z = 0.0

        # Current states
        self.x = 0.0
        self.y = 0.0
        self.z = 0.0
        self.roll = 0.0
        self.pitch = 0.0
        self.yaw = 0.0
        
        self.goal_z = 0.5
        self.goal_y = 0.0
        self.goal_yaw = 0.0
        self.goal_pitch = 0.0
        self.goal_roll = 0.0

        self.hover_throttle = 135
    
        self.prev_roll = 0.0
        self.prev_pitch = 0.0
        self.prev_yaw = 0.0
        # Set previous time to use for derivative term
        self.prev_time = self.get_clock().now().nanoseconds * 10**9
        self.prev_z = None

        # Controller Parameters
        # ------------------------------------------    
        self.z_kp = 0.0
        self.z_kd = 0.0
        self.z_ki = 0.0
    
        self.yaw_kp = 0.0
        self.yaw_kd = 0.0
        self.yaw_ki = 0.0

        self.roll_kp = 146.0
        self.roll_kd = 35.0
        self.roll_ki = 0.0

        self.pitch_kp = 0.0
        self.pitch_kd = 0.0
        self.pitch_ki = 0.0

        self.current_z = 0.0
        # Mixer Matrix 
        # ----------------------------------------------
        # [1, -1,  1,  1  ]
        # [1,  1, -1,  1  ]
        # [1,  1,  1, -1  ]
        # [1, -1, -1, -1  ]
        self.mixer_matrix = np.vstack(
            [[1, -1, 1, 1],
             [1, 1, -1, 1],
             [1, 1, 1, -1], 
             [1, -1, -1, -1]])


        #self.visualize_drone_forces_realtime()
        self.controller_message_array = np.array([0, 0, 0, 0])
        
    def sensor_callback(self, msg: SensorMessage):
        # # During initialization phase, collect sensor data
        # if self.initializing:
        #     if (current_time - self.init_start_time).nanoseconds < 5e9:  # First 5 seconds
        #         self.init_samples.append((msg.roll, msg.pitch, msg.yaw, msg.z))
        #         return
        #     else:
        #         # Calculate averages and finalize initialization
        #         samples = np.array(self.init_samples)
        #         self.init_roll, self.init_pitch, self.init_yaw, self.init_z = np.mean(samples, axis=0)
        #         self.get_logger().info(f"Initialization complete: Roll={self.init_roll}, Pitch={self.init_pitch}, Yaw={self.init_yaw}, Z={self.init_z}")
        #         self.initializing = False
        #         return

        if not self.initialized:
            self.init_roll = msg.roll
            self.init_pitch = msg.pitch
            self.init_yaw = msg.yaw
            self.init_z = self.current_z
            self.initialized = True
            self.get_logger().info("IMU initialized with zero reference values.")
            print("initialized")
            return
        
        #get yaw, roll, pitch
        self.yaw = msg.yaw
        self.roll = msg.roll
        self.pitch = msg.pitch

        # Get current time for derivative term
        curr_time = self.get_clock().now().nanoseconds
        dt = (curr_time - self.prev_time) * 1e-9 # get delta time in nanoseconds
        prev_time = curr_time

        # Get error terms
        z_error = self.goal_z - self.current_z
        z_dot = (self.z - self.prev_z) / dt if self.prev_z is not None and dt > 0 else 0.0
        thrust = self.z_kp * z_error + self.z_kd * z_dot

        roll_error = self.goal_roll - msg.roll
        yaw_error = self.goal_yaw - msg.yaw
        pitch_error = self.goal_pitch - msg.pitch
            
        roll_deriv = (roll_error - self.prev_roll) / dt
        yaw_deriv = (yaw_error - self.prev_yaw) / dt
        pitch_deriv = (pitch_error - self.prev_pitch) / dt
        
        if roll_deriv < 0: 
            print("-------------------- DAMPENING ------------------------ ")
        self.prev_roll = msg.roll
        self.prev_yaw = msg.yaw
        self.prev_pitch = msg.pitch

        if (np.abs(roll_error) > 0.85): 
            failsafe_message = MotorCommand()
            failsafe_message.motor1 = 0
            failsafe_message.motor2 = 0
            failsafe_message.motor3 = 0
            failsafe_message.motor4 = 0
            self.control_publisher.publish(failsafe_message)
            rcply.shutdown()


        # Calculate Inputs
        roll_input = self.roll_kp * roll_error + roll_deriv * self.roll_kd
        yaw_input = 0 #self.yaw_kp * yaw_error + self.yaw_kd * msg.yaw_rate
        pitch_input = self.pitch_kp * pitch_error + self.pitch_kd * msg.pitch_rate

        # Create Vector with Inputs 
        input_vector = np.array([self.hover_throttle + thrust, roll_input, pitch_input, yaw_input]).T
        print(input_vector)
        motor_input = self.mixer_matrix @ input_vector
        print(motor_input)

        
        # Publish motor input
        # Temporarily Flipped
        control_message = MotorCommand()
        if motor_input[0] < 0.0: 
            motor_input[1] += np.abs(motor_input[0])
        if motor_input[1] < 0.0: 
            motor_input[0] += np.abs(motor_input[1])
        if motor_input[2] < 0.0: 
            motor_input[3] += np.abs(motor_input[2])
        if motor_input[3] < 0.0: 
            motor_input[2] += np.abs(motor_input[3])

        control_message.motor1 = max(int(motor_input[2]), 10)
        control_message.motor2 = max(int(motor_input[3]), 10)
        control_message.motor3 = max(int(motor_input[0]), 10)
        control_message.motor4 = max(int(motor_input[1]), 10)
        
        print("Motor Inputs: ")
        print(control_message)
        self.control_publisher.publish(control_message)


        # Debug Half # 
        debug_message = Debug()
        debug_message.proportional = roll_error * self.roll_kp
        debug_message.derivative = roll_error * self.roll_kd 
        debug_message.integral = roll_error * self.roll_ki
        debug_message.roll = msg.roll
        debug_message.roll_error = roll_error
        debug_message.roll_deriv = roll_deriv
        debug_message.time = curr_time * 1e-9

        self.debug_publisher.publish(debug_message)

    #give us rotation matrix, given yaw pitch roll, where theta is 1x3 array
    def eulerAnglesToRotationMatrix(theta) :
    
        R_x = np.array([[1,         0,                  0                   ],
                        [0,         math.cos(theta[0]), -math.sin(theta[0]) ],
                        [0,         math.sin(theta[0]), math.cos(theta[0])  ]
                        ])
    
        R_y = np.array([[math.cos(theta[1]),    0,      math.sin(theta[1])  ],
                        [0,                     1,      0                   ],
                        [-math.sin(theta[1]),   0,      math.cos(theta[1])  ]
                        ])
    
        R_z = np.array([[math.cos(theta[2]),    -math.sin(theta[2]),    0],
                        [math.sin(theta[2]),    math.cos(theta[2]),     0],
                        [0,                     0,                      1]
                        ])
    
        R = np.dot(R_z, np.dot( R_y, R_x ))
    
        return R

    def distance_callback(self, msg):
        #set thetas
        thetas = [self.roll, self.pitch, self.yaw]

        #get rotation matrix
        R = eulerAnglesToRotationMatrix(thetas)

        #find z_dist 
        dist_vec = np.dot(R, [0, 0, msg.z])
        self.current_z = dist_vec[2]

    def path_callback(self, msg: PoseArray):
        coordinate_transform = np.vstack([0, 0, 1],
                                         [1, 0, 0],
                                         [0, 1, 0])
        msg_vector = [msg.poses.x, msg.poses.y, msg.poses.z] 
        goal_vector = coordinate_transform@msg_vector
        self.goal_z = goal_vector[2]
        self.goal_y = goal_vector[1]


    def send_final_command(self):
        final_command = MotorCommand()
        final_command.motor1 = 0
        final_command.motor2 = 0
        final_command.motor3 = 0
        final_command.motor4 = 0
        self.cmd_pub.publish(final_cmd)
        self.get_logger().log('Final Command Sent: [0, 0, 0, 0]')
        rclpy.shutdown()

def main(args=None):
    rclpy.init(args=args)
    controller = PIDController()
    rclpy.spin(controller)
    rclpy.shutdown()

if __name__ == '__main__':
    main()
